# This code does not belong to me nor has been extensively tested.
# It has been generated by AI as a placeholder as a proof of concept
# and a further hand-made iteration is expected to be able to ensure its
# correct functionality and for me to prove I have a pure soul ❤️
if (NOT DEFINED RESOURCES_DIR OR NOT DEFINED OUTPUT_FILE OR NOT DEFINED PROJECT_NAME)
	message(FATAL_ERROR "Missing arguments: PROJECT_NAME, RESOURCES_DIR, OUTPUT_FILE")
endif ()

# --- Helpers ---
set(CONTENT "")
set(INDENT_LEVEL 0)

# Macro para añadir líneas respetando indentación
macro(add_line text)
	string(REPEAT "    " ${INDENT_LEVEL} _indent_str)
	string(APPEND CONTENT "${_indent_str}${text}\n")
endmacro()

macro(sanitize_name input output)
	string(REGEX REPLACE "[ ./-]" "_" ${output} "${input}")
	string(TOUPPER "${${output}}" ${output})
endmacro()

# --- Header Generation ---
add_line("#pragma once")
add_line("#include \"Resources.h\"\n")

add_line("namespace Mistral")
add_line("{")
math(EXPR INDENT_LEVEL "${INDENT_LEVEL} + 1")
add_line("inline const std::filesystem::path& Get${PROJECT_NAME}ResourcesPath()")
add_line("{")
math(EXPR INDENT_LEVEL "${INDENT_LEVEL} + 1")
string(TOLOWER ${PROJECT_NAME} PROJ_LOWER)
add_line("static auto path = GetExecutablePath() / \"${PROJ_LOWER}_resources\";")
add_line("return path;")
math(EXPR INDENT_LEVEL "${INDENT_LEVEL} - 1")
add_line("}")
math(EXPR INDENT_LEVEL "${INDENT_LEVEL} - 1")
add_line("}")

add_line("")

add_line("namespace RESOURCES")
add_line("{")
math(EXPR INDENT_LEVEL "${INDENT_LEVEL} + 1")

# --- Recursive File Loop ---
file(GLOB_RECURSE FOUND_FILES RELATIVE "${RESOURCES_DIR}" "${RESOURCES_DIR}/*")
list(SORT FOUND_FILES)

set(CURRENT_STACK "")
set(BASE_CALL "Mistral::Get${PROJECT_NAME}ResourcesPath()")

foreach (FILE_PATH ${FOUND_FILES})
	# Skip hidden files
	if (FILE_PATH MATCHES "(^|/)\\.")
		continue()
	endif()

	get_filename_component(DIR_PATH "${FILE_PATH}" DIRECTORY)
	get_filename_component(FILE_NAME "${FILE_PATH}" NAME_WE)
	string(REPLACE "/" ";" TARGET_STACK "${DIR_PATH}")

	# 1. Calculate common depth
	set(COMMON_DEPTH 0)
	list(LENGTH CURRENT_STACK LEN_CURR)
	list(LENGTH TARGET_STACK LEN_TARG)

	set(MAX_I ${LEN_CURR})
	if(LEN_TARG LESS LEN_CURR)
		set(MAX_I ${LEN_TARG})
	endif()

	if(MAX_I GREATER 0)
		foreach(I RANGE 1 ${MAX_I})
			math(EXPR IDX "${I}-1")
			list(GET CURRENT_STACK ${IDX} C_VAL)
			list(GET TARGET_STACK ${IDX} T_VAL)
			if(NOT C_VAL STREQUAL T_VAL)
				break()
			endif()
			math(EXPR COMMON_DEPTH "${COMMON_DEPTH} + 1")
		endforeach()
	endif()

	# 2. Close old namespaces
	if(LEN_CURR GREATER COMMON_DEPTH)
		math(EXPR TO_CLOSE "${LEN_CURR} - ${COMMON_DEPTH}")
		foreach(I RANGE 1 ${TO_CLOSE})
			math(EXPR INDENT_LEVEL "${INDENT_LEVEL} - 1")
			add_line("}")
			add_line("")
		endforeach()
	endif()

	# 3. Open new namespaces
	if(LEN_TARG GREATER COMMON_DEPTH)
		math(EXPR START "${COMMON_DEPTH}")
		math(EXPR END "${LEN_TARG} - 1")
		foreach(I RANGE ${START} ${END})
			list(GET TARGET_STACK ${I} DIR_NAME)
			sanitize_name("${DIR_NAME}" SAFE_DIR)
			add_line("namespace ${SAFE_DIR}")
			add_line("{")
			math(EXPR INDENT_LEVEL "${INDENT_LEVEL} + 1")
		endforeach()
	endif()

	set(CURRENT_STACK ${TARGET_STACK})

	# 4. Add File Variable
	sanitize_name("${FILE_NAME}" SAFE_VAR)
	add_line("inline const auto ${SAFE_VAR} = ${BASE_CALL} / \"${FILE_PATH}\";")
endforeach()

# --- Close remaining namespaces ---
list(LENGTH CURRENT_STACK LEN_FINAL)
foreach(I RANGE 1 ${LEN_FINAL})
	math(EXPR INDENT_LEVEL "${INDENT_LEVEL} - 1")
	add_line("}")
endforeach()

math(EXPR INDENT_LEVEL "${INDENT_LEVEL} - 1")
add_line("}") # Close RESOURCES

# --- Write to Disk ---
if(EXISTS "${OUTPUT_FILE}")
	file(READ "${OUTPUT_FILE}" OLD_CONTENT)
endif()

if(NOT "${CONTENT}" STREQUAL "${OLD_CONTENT}")
	file(WRITE "${OUTPUT_FILE}" "${CONTENT}")
endif()